{"version":3,"sources":["athens/subs.cljs"],"mappings":";;;;;AASA,AAAAA,AAAA;AAAAC,AAEC,AAAKE,AAAGC;AAAR,AACE,AAAA,AAAYD;;AAHf,AAAA,AAAAH,AAAAC,AAAAD,AAAAC,AAACC,AAAAA,AAAAA;AAOD,AAAAG,AAAA;AAAAC,AAAA,AAAA;AAAA,AAAA,AAAAD,AAAAC,AAAAD,AAAAC,AAACC,AAAAA,AAAAA;AAWD,AAAAC,AAAA;AAAAC,AAAA,AAAA;AAAA,AAAA,AAAAD,AAAAC,AAAAD,AAAAC,AAACC,AAAAA,AAAAA;AAID,AAAAC,AAAA;AAAAC,AAAA,AAAA;AAAA,AAAA,AAAAD,AAAAC,AAAAD,AAAAC,AAACF,AAAAA,AAAAA;AAID,AAAAG,AAAA;AAAAC,AAAA,AAAA;AAAA,AAAA,AAAAD,AAAAC,AAAAD,AAAAC,AAACJ,AAAAA,AAAAA;AAID,AAAAK,AAAA;AAAAC,AAAA,AAAA;AAAA,AAAA,AAAAD,AAAAC,AAAAD,AAAAC,AAACN,AAAAA,AAAAA;AAID,AAAAO,AAAA;AAAAC,AAAA,AAAA;AAAA,AAAA,AAAAD,AAAAC,AAAAD,AAAAC,AAACR,AAAAA,AAAAA;AAKD,AAAAS,AAAA;AAAAC,AAAA,AAAA;AAAA,AAAA,AAAAD,AAAAC,AAAAD,AAAAC,AAACV,AAAAA,AAAAA;AAID,AAAAW,AAAA;AAAAC,AAEE,AAAAE,AAAYpB;AAAZ,AAAA,AAAAqB,AAAAD;AAAA,AAAAE,AAAAD,AAAA,AAAA,AAAMrB;AAAN,AAAAsB,AAAAD,AAAA,AAAA,AAAQE;AAAR,AACC,AAAAC,AAAA,AAAA,AAA6BD;AAA7B,AAAA,AAAAC,AAAAA,AAACC,AAAAA,AAAAA;;AAHJN,AAIE,AAAKO,AAAM1B;AAAX,AACE,AAAC2B,AACA,AAACC,AACA,AAAOC,AAAEH;AAAT,AACOI;;AADP,AAEE,AAAI,AAAA,AAAaD;AACf,AAACE,AAAKD,AAAID;;AACV,AAAO,AAACG,AAAM,AAAA,AAAkBH;AACzB,AAACE,AAAKD,AAAI,AAAA,AAACG,AAAOJ;;;;;;;;;AAZnC,AAAA,AAAAZ,AAAAC,AAAAC,AAAAF,AAAAC,AAAAC,AAACrB,AAAAA,AAAAA;AAeD,AAAAoC,AAAA;AAAAC,AAAA,AAAA;AAAA,AAAA,AAAAD,AAAAC,AAAAD,AAAAC,AAAChC,AAAAA,AAAAA","names":["G__70494","G__70495","re-frame.core/reg-sub","db","_","G__70496","G__70497","re-posh.core/reg-query-sub","G__70498","G__70499","re-posh.core/reg-pull-sub","G__70500","G__70501","G__70502","G__70503","G__70506","G__70507","G__70513","G__70514","G__70515","G__70516","G__70518","G__70519","G__70520","p__70521","vec__70531","cljs.core.nth.cljs$core$IFn$_invoke$arity$3","id","G__70534","re-frame.core/subscribe","block","cljs.core/reverse","cljs.core/rest","b","res","cljs.core.conj.cljs$core$IFn$_invoke$arity$2","cljs.core/first","cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2","G__70536","G__70537"],"sourcesContent":["(ns athens.subs\n  (:require\n   [re-frame.core :as rf :refer [subscribe]]\n   [re-posh.core :as rp :refer [reg-query-sub reg-pull-sub reg-pull-many-sub]]\n   [day8.re-frame.tracing :refer-macros [fn-traced]]))\n; note: not refering reg-sub because re-posh and re-frame have different reg-subs\n\n\n; re-frame subscriptions\n(rf/reg-sub\n :user/name\n (fn [db _]\n   (:user/name db)\n   ))\n\n;; datascript queries\n(reg-query-sub\n :nodes\n '[:find ?e ?t ?b ?et ?ct\n   :where\n   [?e :node/title ?t]\n   [?e :block/uid ?b]\n   [?e :create/time ?ct]\n   [?e :edit/time ?et]\n   ])\n\n;; datascript pulls\n(reg-pull-sub\n :node\n '[*])\n\n(reg-pull-sub\n :block/uid\n '[:block/uid])\n\n(reg-pull-sub\n :block/string\n '[:block/string])\n\n(reg-pull-sub\n :blocks\n '[:block/string {:block/children ...}])\n\n(reg-pull-sub\n :block/children\n '[:block/uid :block/string {:block/children ...}])\n\n; layer 3 subscriptions\n(reg-pull-sub\n :block/_children\n '[:block/uid :block/string :node/title {:block/_children ...}])\n\n(rf/reg-sub\n :block/_children2\n  (fn [[_ id] _]\n   (subscribe [:block/_children id]))\n  (fn [block _] ; find path from nested block to origin node\n    (reverse\n     (rest\n      (loop [b block\n             res []]\n        (if (:node/title b)\n          (conj res b)\n          (recur (first (:block/_children b))\n                 (conj res (dissoc b :block/_children)))))))))\n\n\n(reg-query-sub\n :node/refs\n '[:find ?id\n   :in $ ?regex\n   :where\n   [?e :block/string ?s]\n   [(re-find ?regex ?s)]\n   [?e :block/uid ?id]])\n\n;; (rp/reg-sub\n;;  :node/refs2\n;;  (fn [[_ regex]]\n;;    (subscribe [:node/refs regex]))\n;;  (fn [ids _] ; for all refs, find their parents with reverse lookup\n;;    {:type :pull-many\n;;     :pattern '[:node/title :block/uid :block/string {:block/_children ...}]\n;;     :ids (reduce into [] ids)}))\n\n;; (rf/reg-sub\n;;  :node/refs3\n;;  (fn [[_ regex]]\n;;    (subscribe [:node/refs2 regex]))\n;;  (fn [blocks _]\n;;    ;; flatten paths like in :block/_children2 (except keep node/title)\n;;    ;; then normalize refs through group by :node/title\n;;    (->> blocks\n;;         (map (fn [block]\n;;                (reverse\n;;                 (loop [b block\n;;                        res []]\n;;                   (if (:node/title b)\n;;                     (conj res (dissoc b :block/children))\n;;                     (recur (first (:block/_children b))\n;;                            (conj res (dissoc b :block/_children))))))))\n;;         (group-by #(:node/title (first %)))\n;;         (reduce-kv (fn [m k v]\n;;                      (assoc m k (map rest v))) {} ))\n;;    ))\n"]}